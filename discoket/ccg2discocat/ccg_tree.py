from __future__ import annotations

__all__ = ['CCGTree']

import json
from typing import Any, Dict, Optional, Sequence, Tuple, Union, overload

from discopy import biclosed, rigid, Word
from discopy.biclosed import Diagram, Functor, Id, Ty, biclosed2rigid_ob

from discoket.ccg2discocat.ccg_rule import CCGAtomicType, CCGRule

# Types
JSONDict = Dict[str, Any]


class PlanarBX(biclosed.Box):
    def __init__(self, left: Ty, diagram: Diagram) -> None:
        assert isinstance(left, biclosed.Over)
        assert not diagram.dom

        right = diagram.cod
        assert isinstance(right, biclosed.Under)
        assert left.left == right.left

        self.left = left
        self.diagram = diagram
        dom, cod = left, right.right << left.right
        super().__init__(f'PlanarBX({left}, {diagram})', dom, cod)


def biclosed2str(biclosed_type: Ty, pretty: bool = False) -> str:
    if isinstance(biclosed_type, biclosed.Over):
        template = '({0}↢{1})' if pretty else '({0}/{1})'
    elif isinstance(biclosed_type, biclosed.Under):
        template = '({0}↣{1})' if pretty else r'({1}\{0})'
    else:
        return str(biclosed_type)
    return template.format(biclosed2str(biclosed_type.left, pretty),
                           biclosed2str(biclosed_type.right, pretty))


def str2biclosed(string: str, index: int = 0) -> Union[Ty, Tuple[Ty, int]]:
    """Parse a string of the form generated by `biclosed2str`."""

    if string[index] != '(':  # base case
        end = index + 1
        while end < len(string):
            if string[end] in r'\/)':
                break
            end += 1
        biclosed_type = Ty(string[index:end])
    else:
        left, end = str2biclosed(string, index + 1)
        op = string[end]
        assert op in r'\/'

        right, end = str2biclosed(string, end + 1)
        assert string[end] == ')'

        biclosed_type = left << right if op == '/' else right >> left
        end += 1
    return (biclosed_type, end) if index else biclosed_type


class CCGTree:
    """Derivation tree for a CCG.

    This provides a standard derivation interface between the parser and
    the rest of the model.
    """

    def __init__(self,
                 text: Optional[str] = None,
                 *,
                 ccg_rule: Union[str, CCGRule] = CCGRule.UNKNOWN,
                 biclosed_type: Ty,
                 children: Optional[Sequence[CCGTree]] = None) -> None:
        self._text = text
        self.rule = CCGRule(ccg_rule)
        self.biclosed_type = biclosed_type
        self.children = children if children is not None else []

    @property
    def text(self) -> str:
        if self._text is None:
            self._text = ' '.join(child.text for child in self.children)
        return self._text

    @overload
    @classmethod
    def from_json(cls, data: None) -> None: ...

    @overload
    @classmethod
    def from_json(cls, data: Union[str, JSONDict]) -> CCGTree: ...

    @classmethod
    def from_json(cls,
                  data: Union[None, str, JSONDict]) -> Optional[CCGTree]:
        if data is None:
            return None

        data_dict = json.loads(data) if isinstance(data, str) else data
        return cls(text=data_dict.get('text'),
                   ccg_rule=data_dict.get('rule', CCGRule.UNKNOWN),
                   biclosed_type=str2biclosed(data_dict['type']),
                   children=[cls.from_json(child)
                             for child in data_dict.get('children', [])])

    def to_json(self) -> JSONDict:
        data: JSONDict = {'type': biclosed2str(self.biclosed_type)}
        if self.rule != CCGRule.UNKNOWN:
            data['rule'] = self.rule.value
        if self.text != ' '.join(child.text for child in self.children):
            data['text'] = self.text
        if self.children:
            data['children'] = [child.to_json() for child in self.children]
        return data

    def __eq__(self, other: Any) -> bool:
        return (isinstance(other, CCGTree) and
                self.text == other.text and
                self.rule == other.rule and
                self.biclosed_type == other.biclosed_type and
                len(self.children) == len(other.children) and
                all(c1 == c2 for c1, c2 in zip(self.children, other.children)))

    def __repr__(self) -> str:  # pragma: no cover
        return f'{type(self).__name__}("{self.text}")'

    @property
    def is_terminal(self) -> bool:
        return len(self.children) == 0

    @property
    def is_unary(self) -> bool:
        return len(self.children) == 1

    def deriv(self,
              use_slashes: bool = False,
              prefix: str = '') -> str:  # pragma: no cover
        output_type = biclosed2str(self.biclosed_type, not use_slashes)
        if self.is_terminal:
            deriv = f' {output_type} ∋ "{self.text}"'
        else:
            deriv = (f'{self.rule}: {output_type} ← ' +
                     ' + '.join(biclosed2str(child.biclosed_type, True)
                                for child in self.children))
        deriv = f'{prefix}{deriv}'

        if self.children:
            if prefix:
                prefix = prefix[:-1] + ('│ ' if prefix[-1] == '├' else '  ')
            for child in self.children[:-1]:
                deriv += '\n' + child.deriv(use_slashes, prefix + '├')
            deriv += '\n' + self.children[-1].deriv(use_slashes, prefix + '└')
        return deriv

    def to_biclosed_diagram(self,
                            separate_words: bool = False,
                            planar: bool = False,
                            resolved_output: Optional[Ty] = None) -> Diagram:
        biclosed_type = resolved_output or self.biclosed_type

        if self.is_terminal:
            word = biclosed.Box(self.text, Ty(), biclosed_type)
            return (word, Id(biclosed_type)) if separate_words else word

        child_types = [child.biclosed_type for child in self.children]

        this_layer = self.rule(Ty.tensor(*child_types), biclosed_type)

        children = [child.to_biclosed_diagram(True,
                                              planar,
                                              this_layer.dom[i:i+1])
                    for i, child in enumerate(self.children)]

        if planar and self.rule == CCGRule.BACKWARD_CROSSED_COMPOSITION:
            (words, left_diag), (right_words, right_diag) = children
            diag = (left_diag >> PlanarBX(left_diag.cod,
                                          right_words >> right_diag))
        else:
            words, diag = [Diagram.tensor(*d) for d in zip(*children)]
            diag >>= this_layer

        if separate_words:
            return words, diag
        else:
            return words >> diag

    def to_diagram(self, planar: bool = False) -> rigid.Diagram:
        def ob_func(ob: Ty) -> rigid.Ty:
            return (rigid.Ty() if ob == CCGAtomicType.PUNCTUATION
                    else biclosed2rigid_ob(ob))

        def ar_func(box: biclosed.Box) -> rigid.Diagram:
            # PlanarBX box          -> planar bx diagram
            # RemovePunctuation box -> identity wire(s)
            # or        punctuation -> empty diagram
            # else         word box -> Word

            if isinstance(box, PlanarBX):
                dom = to_rigid_diagram(box.left)
                left = to_rigid_diagram(box.left.left)
                right = dom[len(left):]
                rigid_box = to_rigid_diagram(box.diagram)
                cups = rigid.cups(left, left.r)
                return (Id(dom) >>
                        Id(left) @ rigid_box @ Id(right) >>
                        cups @ Id(rigid_box.cod[len(left):] @ right))

            cod = ob_func(box.cod)
            return Id(cod) if box.dom or not cod else Word(box.name, cod)

        to_rigid_diagram = Functor(ob=ob_func,
                                   ar=ar_func,
                                   ob_factory=rigid.Ty,
                                   ar_factory=rigid.Diagram)
        return to_rigid_diagram(self.to_biclosed_diagram(planar=planar))
